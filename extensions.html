

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Extensions &mdash; Flasker 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="Flasker 0.1 documentation" href="index.html" />
    <link rel="next" title="Utilities" href="util.html" />
    <link rel="prev" title="Overview" href="project.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Flasker 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>Extensions</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="project.html">Overview</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="util.html">Utilities</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="extensions">
<h1>Extensions<a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-flasker.ext.orm">
<span id="orm"></span><h2>ORM<a class="headerlink" href="#module-flasker.ext.orm" title="Permalink to this headline">¶</a></h2>
<p>ORM Extension</p>
<p>This extension provides a customized SQLAlchemy model base and query.</p>
<p>Setup is straightforward:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flasker</span> <span class="kn">import</span> <span class="n">current_project</span> <span class="k">as</span> <span class="n">pj</span>
<span class="kn">from</span> <span class="nn">flasker.ext</span> <span class="kn">import</span> <span class="n">ORM</span>

<span class="n">orm</span> <span class="o">=</span> <span class="n">ORM</span><span class="p">(</span><span class="n">pj</span><span class="p">)</span>

<span class="n">Model</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">Model</span>                 <span class="c"># the customized base</span>
<span class="n">relationship</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">relationship</span>   <span class="c"># the customized relationship</span>
<span class="n">backref</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">backref</span>             <span class="c"># the associated backref</span>
</pre></div>
</div>
<p>Models can now be created by subclassing <tt class="docutils literal"><span class="pre">orm.Model</span></tt> as follows:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>

<span class="k">class</span> <span class="nc">House</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>

  <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
  <span class="n">address</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Cat</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    
  <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
  <span class="n">house_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s">&#39;houses.id&#39;</span><span class="p">))</span>

  <span class="n">house</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s">&#39;House&#39;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="n">backref</span><span class="p">(</span><span class="s">&#39;cats&#39;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s">&#39;dynamic&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that tablenames are automatically generated by default. For an
exhaustive list of all the properties and methods provided by <tt class="docutils literal"><span class="pre">orm.Model</span></tt>
please refer to the documentation for <a class="reference internal" href="#flasker.ext.orm.BaseModel" title="flasker.ext.orm.BaseModel"><tt class="xref py py-class docutils literal"><span class="pre">flasker.ext.orm.BaseModel</span></tt></a> below.</p>
<p>Models can be queried in several ways:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># the two following queries are equivalent</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">pj</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Cat</span><span class="p">)</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">Cat</span><span class="o">.</span><span class="n">q</span>
</pre></div>
</div>
<p>Both queries above are instances of <a class="reference internal" href="#flasker.ext.orm.Query" title="flasker.ext.orm.Query"><tt class="xref py py-class docutils literal"><span class="pre">flasker.ext.orm.Query</span></tt></a>, which are
customized <tt class="docutils literal"><span class="pre">sqlalchemy.orm.Query</span></tt> objects (cf. below for the list of
available methods). If relationships (and backrefs) are defined using the
<tt class="docutils literal"><span class="pre">orm.relationship</span></tt> and <tt class="docutils literal"><span class="pre">orm.backref</span></tt> functions, appender queries will
also return custom queries:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">house</span> <span class="o">=</span> <span class="n">House</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">relationship_query</span> <span class="o">=</span> <span class="n">house</span><span class="o">.</span><span class="n">cats</span>   <span class="c"># instance of flasker.ext.orm.Query</span>
</pre></div>
</div>
<p>Finally, there is a special property <tt class="docutils literal"><span class="pre">c</span></tt> exposed on all children of
<tt class="docutils literal"><span class="pre">orm.Model</span></tt> that returns an optimized count query (by default SQLAlchemy
count queries use subqueries which are very slow).  This is useful when
counting over large numbers of rows (10k and more), as the following benchmark
shows (~250k rows):</p>
<div class="code python highlight-python"><pre>In [1]: %time Cat.q.count()
CPU times: user 0.01 s, sys: 0.00 s, total: 0.01 s
Wall time: 1.36 s
Out[1]: 281992L

In [2]: %time Cat.c.scalar()
CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
Wall time: 0.06 s
Out[2]: 281992L</pre>
</div>
<dl class="class">
<dt id="flasker.ext.orm.ORM">
<em class="property">class </em><tt class="descclassname">flasker.ext.orm.</tt><tt class="descname">ORM</tt><big>(</big><em>project</em>, <em>create_all=True</em><big>)</big><a class="reference internal" href="_modules/flasker/ext/orm.html#ORM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.orm.ORM" title="Permalink to this definition">¶</a></dt>
<dd><p>The main ORM object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>project</strong> (<a class="reference internal" href="project.html#flasker.project.Project" title="flasker.project.Project"><em>flasker.project.Project</em></a>) &#8211; the project against which the extension will be registered</li>
<li><strong>create_all</strong> (<em>bool</em>) &#8211; whether or not to automatically create tables for the
models defined (<tt class="docutils literal"><span class="pre">True</span></tt> by default). Tables will only be created for
models which do not have one already.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>When this object is initialized, it is responsible for adding the <tt class="docutils literal"><span class="pre">q</span></tt> and
<tt class="docutils literal"><span class="pre">c</span></tt> query proxies on the model and configuring the project to use the
custom <a class="reference internal" href="#flasker.ext.orm.Query" title="flasker.ext.orm.Query"><tt class="xref py py-class docutils literal"><span class="pre">flasker.ext.orm.Query</span></tt></a> class.</p>
</dd></dl>

<dl class="class">
<dt id="flasker.ext.orm.Query">
<em class="property">class </em><tt class="descclassname">flasker.ext.orm.</tt><tt class="descname">Query</tt><big>(</big><em>entities</em>, <em>session=None</em><big>)</big><a class="reference internal" href="_modules/flasker/ext/orm.html#Query"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.orm.Query" title="Permalink to this definition">¶</a></dt>
<dd><p>Base query class.</p>
<p>All queries and relationships/backrefs defined using this extension will
return an instance of this class.</p>
<dl class="method">
<dt id="flasker.ext.orm.Query.get_or_404">
<tt class="descname">get_or_404</tt><big>(</big><em>model_id</em><big>)</big><a class="reference internal" href="_modules/flasker/ext/orm.html#Query.get_or_404"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.orm.Query.get_or_404" title="Permalink to this definition">¶</a></dt>
<dd><p>Like get but aborts with 404 if not found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>model_id</strong> (<em>varies</em>) &#8211; the model&#8217;s primary key</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">model or HTTPError</td>
</tr>
</tbody>
</table>
<p>This method is from Flask-SQLAlchemy.</p>
</dd></dl>

<dl class="method">
<dt id="flasker.ext.orm.Query.first_or_404">
<tt class="descname">first_or_404</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/flasker/ext/orm.html#Query.first_or_404"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.orm.Query.first_or_404" title="Permalink to this definition">¶</a></dt>
<dd><p>Like first but aborts with 404 if not found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">model or HTTPError</td>
</tr>
</tbody>
</table>
<p>This method is from Flask-SQLAlchemy.</p>
</dd></dl>

<dl class="method">
<dt id="flasker.ext.orm.Query.random">
<tt class="descname">random</tt><big>(</big><em>n=1</em>, <em>dialect=None</em><big>)</big><a class="reference internal" href="_modules/flasker/ext/orm.html#Query.random"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.orm.Query.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns n random model instances.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>int</em>) &#8211; the number of instances to return</li>
<li><strong>dialect</strong> (<em>str</em>) &#8211; the engine dialect (the implementation of random differs
between MySQL and SQLite among others). By default will look up on the
query for the dialect used. If no random function is available for the 
chosen dialect, the fallback implementation uses total row count to 
generate random offsets.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">model instances</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flasker.ext.orm.Query.to_dataframe">
<tt class="descname">to_dataframe</tt><big>(</big><em>lazy=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flasker.ext.orm.Query.to_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a dataframe with the records from the query and returns it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lazy</strong> (<em>bool</em>) &#8211; whether or not to load the underlying objects. If set to
<tt class="docutils literal"><span class="pre">False</span></tt>, the dataframe will be populated with the contents of
<tt class="docutils literal"><span class="pre">to_json</span></tt> of the models, otherwise it will only contain the columns
existing in the database (default behavior). If lazy is <tt class="docutils literal"><span class="pre">True</span></tt>, this
method also accepts the same keyword arguments as
<a class="reference internal" href="util.html#flasker.util.query_to_dataframe" title="flasker.util.query_to_dataframe"><tt class="xref py py-func docutils literal"><span class="pre">flasker.util.query_to_dataframe()</span></tt></a>. For convenience, if no
<tt class="docutils literal"><span class="pre">exclude</span></tt> kwarg is specified, it will default to <tt class="docutils literal"><span class="pre">['_cache']</span></tt>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">pandas.DataFrame</td>
</tr>
</tbody>
</table>
<p>Requires the <tt class="docutils literal"><span class="pre">pandas</span></tt> library to be installed.</p>
</dd></dl>

<dl class="method">
<dt id="flasker.ext.orm.Query.to_records">
<tt class="descname">to_records</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#flasker.ext.orm.Query.to_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Raw execute of the query into a generator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">generator</td>
</tr>
</tbody>
</table>
<p>This method accepts the same keyword arguments as 
<a class="reference internal" href="util.html#flasker.util.query_to_records" title="flasker.util.query_to_records"><tt class="xref py py-func docutils literal"><span class="pre">flasker.util.query_to_records()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flasker.ext.orm.BaseModel">
<em class="property">class </em><tt class="descclassname">flasker.ext.orm.</tt><tt class="descname">BaseModel</tt><a class="headerlink" href="#flasker.ext.orm.BaseModel" title="Permalink to this definition">¶</a></dt>
<dd><p>The custom SQLAlchemy base.</p>
<p>Along with the methods described below, the following conveniences are
provided:</p>
<ul class="simple">
<li>Automatic table naming (to the model&#8217;s class name uncamelcased with an
extra s appended for good measure). To disable this behavior, simply
override the <tt class="docutils literal"><span class="pre">__tablename__</span></tt> argument (setting it to <tt class="docutils literal"><span class="pre">None</span></tt> for
single table inheritance).</li>
<li>Default implementation of <tt class="docutils literal"><span class="pre">__repr__</span></tt> with model class and primary keys</li>
<li>Caching (inherited from <a class="reference internal" href="util.html#flasker.util.Cacheable" title="flasker.util.Cacheable"><tt class="xref py py-class docutils literal"><span class="pre">flasker.util.Cacheable</span></tt></a>). The cache is
persistent by default (<tt class="docutils literal"><span class="pre">_cache</span></tt> is actually a
<a class="reference internal" href="util.html#flasker.util.JSONEncodedDict" title="flasker.util.JSONEncodedDict"><tt class="xref py py-class docutils literal"><span class="pre">flasker.util.JSONEncodedDict</span></tt></a> column).</li>
<li>Logging (inherited from <a class="reference internal" href="util.html#flasker.util.Loggable" title="flasker.util.Loggable"><tt class="xref py py-class docutils literal"><span class="pre">flasker.util.Loggable</span></tt></a>)</li>
</ul>
<p>Recall that the <tt class="docutils literal"><span class="pre">q</span></tt> and <tt class="docutils literal"><span class="pre">c</span></tt> query properties are also available.</p>
<dl class="classmethod">
<dt id="flasker.ext.orm.BaseModel.retrieve">
<em class="property">classmethod </em><tt class="descname">retrieve</tt><big>(</big><em>flush_if_new=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flasker.ext.orm.BaseModel.retrieve" title="Permalink to this definition">¶</a></dt>
<dd><p>Given constructor arguments will return a match or create one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>flush_if_new</strong> (<em>bool</em>) &#8211; whether or not to flush the model if created (this
can be used to generate its <tt class="docutils literal"><span class="pre">id</span></tt>).</li>
<li><strong>kwargs</strong> &#8211; constructor arguments</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
<p>This method returns a tuple <tt class="docutils literal"><span class="pre">(model,</span> <span class="pre">flag)</span></tt> where <tt class="docutils literal"><span class="pre">model</span></tt> is of the
corresponding class and <tt class="docutils literal"><span class="pre">flag</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt> if the model was just created
and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="flasker.ext.orm.BaseModel.get_primary_key">
<tt class="descname">get_primary_key</tt><big>(</big><em>as_tuple=False</em><big>)</big><a class="headerlink" href="#flasker.ext.orm.BaseModel.get_primary_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of primary keys for the given model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>as_tuple</strong> (<em>bool</em>) &#8211; if set to <tt class="docutils literal"><span class="pre">True</span></tt>, this method will return a tuple with
the model&#8217;s primary key values. Otherwise a dictionary is returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict, tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flasker.ext.orm.BaseModel.to_json">
<tt class="descname">to_json</tt><big>(</big><em>depth=1</em>, <em>expand=True</em><big>)</big><a class="headerlink" href="#flasker.ext.orm.BaseModel.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Serializes the model into a dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>depth</strong> (<em>int</em>) &#8211; </li>
<li><strong>expand</strong> (<em>bool</em>) &#8211; whether or not to repeat keys when jsonifying nested
objects (defaults to <tt class="docutils literal"><span class="pre">True</span></tt>). This is useful when the frontend
has model support (e.g. using Backbone-Relational).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
<p>The following attributes are included in the returned JSON:</p>
<ul class="simple">
<li>all non private columns</li>
<li>all non private properties</li>
<li>all non private relationships which have their <tt class="docutils literal"><span class="pre">lazy</span></tt> attribute set to
one of <tt class="docutils literal"><span class="pre">False,</span> <span class="pre">'joined',</span> <span class="pre">'immediate'</span></tt></li>
</ul>
<p>A consequence of this is that this method will never issue extra queries
to populate the JSON. Furthermore, all the attribute names to be
included are computed at class declaration so this method is very fast.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To change which attributes are included in the dictionary, you can 
override the <tt class="docutils literal"><span class="pre">__json__</span></tt> attribute.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p><em>under development</em></p>
<span class="target" id="module-flasker.ext.api"></span><p>API Extension (requires the ORM extension).</p>
<p>This extension provides a base class to create API views.</p>
<p>Setup is as follows:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flasker</span> <span class="kn">import</span> <span class="n">current_project</span> <span class="k">as</span> <span class="n">pj</span>
<span class="kn">from</span> <span class="nn">flasker.ext</span> <span class="kn">import</span> <span class="n">API</span>

<span class="n">api</span> <span class="o">=</span> <span class="n">API</span><span class="p">(</span><span class="n">pj</span><span class="p">)</span>

<span class="n">View</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">View</span>   <span class="c"># the base API view</span>
</pre></div>
</div>
<p>Views can then be created for models as follows:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Cat is a subclass of flasker.ext.orm.Base</span>

<span class="k">class</span> <span class="nc">CatView</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>

  <span class="n">__model__</span> <span class="o">=</span> <span class="n">Cat</span>
</pre></div>
</div>
<p>This view will create the following hooks:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">/cats</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/cats/&lt;id&gt;</span></tt></li>
</ul>
<p>Another slighly more complex example:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># House is a subclass of flasker.ext.orm.Base</span>

<span class="k">class</span> <span class="nc">HouseView</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>

  <span class="n">__model__</span> <span class="o">=</span> <span class="n">House</span>

  <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="s">&#39;POST&#39;</span><span class="p">]</span>
  <span class="n">relationship_views</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;cats&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>This view will create the following hooks:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">/houses</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/houses/&lt;id&gt;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/houses/&lt;id&gt;/cats</span></tt></li>
<li><tt class="docutils literal"><span class="pre">/houses/&lt;id&gt;/cats/&lt;position&gt;</span></tt></li>
</ul>
<p>These are only two simple ways to add a view. Please refer to the documentation
for <a class="reference internal" href="#flasker.ext.api.BaseView" title="flasker.ext.api.BaseView"><tt class="xref py py-class docutils literal"><span class="pre">flasker.ext.api.BaseView</span></tt></a> for the list of all available options.</p>
<dl class="exception">
<dt id="flasker.ext.api.APIError">
<em class="property">exception </em><tt class="descclassname">flasker.ext.api.</tt><tt class="descname">APIError</tt><big>(</big><em>code</em>, <em>content</em><big>)</big><a class="reference internal" href="_modules/flasker/ext/api.html#APIError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.api.APIError" title="Permalink to this definition">¶</a></dt>
<dd><p>Thrown when an API call is invalid.</p>
<p>The following error codes can occur:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">400</span> <span class="pre">Bad</span> <span class="pre">Request</span></tt> if the request is badly formulated (wrong query
parameters, invalid form data, etc.)</li>
<li><tt class="docutils literal"><span class="pre">403</span> <span class="pre">Forbidden</span></tt> if the request is not authorized by the server</li>
<li><tt class="docutils literal"><span class="pre">404</span> <span class="pre">Not</span> <span class="pre">Found</span></tt> if the request refers to a non-existent resource</li>
</ul>
</dd></dl>

<dl class="class">
<dt id="flasker.ext.api.API">
<em class="property">class </em><tt class="descclassname">flasker.ext.api.</tt><tt class="descname">API</tt><big>(</big><em>project</em>, <em>url_prefix='api'</em>, <em>index_view=True</em>, <em>parser_options=None</em><big>)</big><a class="reference internal" href="_modules/flasker/ext/api.html#API"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.api.API" title="Permalink to this definition">¶</a></dt>
<dd><p>The main API object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>project</strong> (<a class="reference internal" href="project.html#flasker.project.Project" title="flasker.project.Project"><em>flasker.project.Project</em></a>) &#8211; the project against which the extension will be registered</li>
<li><strong>url_prefix</strong> (<em>str</em>) &#8211; the blueprint URL prefix</li>
<li><strong>index_view</strong> (<em>bool</em>) &#8211; whether or not to create a splash page for the api</li>
<li><strong>parser_options</strong> (<em>dict</em>) &#8211; dictionary of options to create the default request
<a class="reference internal" href="#flasker.ext.api.Parser" title="flasker.ext.api.Parser"><tt class="xref py py-class docutils literal"><span class="pre">flasker.ext.api.Parser</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="flasker.ext.api.BaseView">
<em class="property">class </em><tt class="descclassname">flasker.ext.api.</tt><tt class="descname">BaseView</tt><a class="headerlink" href="#flasker.ext.api.BaseView" title="Permalink to this definition">¶</a></dt>
<dd><p>Base API view. Not an actual view.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Model</strong> &#8211; the <tt class="docutils literal"><span class="pre">Model</span></tt> subclass to be exposed.</li>
<li><strong>relationships</strong> &#8211; <p>whether or not to create subroutes for the model&#8217;s
lazy and dynamic relationships. This parameter can take the following
values:</p>
<ul>
<li><tt class="docutils literal"><span class="pre">True</span></tt> to create routes for all</li>
<li><tt class="docutils literal"><span class="pre">False</span></tt> to create none</li>
<li>a list of relationship keys to create routes for</li>
</ul>
</li>
<li><strong>methods</strong> &#8211; <p>which request methods to allow. Can take the following
values:</p>
<ul>
<li><tt class="docutils literal"><span class="pre">True</span></tt> to allow all</li>
<li>a list of methods to allow</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Calling this function multiple times will override any options previously 
set for the Model.</p>
<p>..note:</p>
<div class="highlight-python"><pre>Only relationships with ``lazy`` set to ``'dynamic'``, ``'select'`` or
``True`` can have subroutes. All eagerly loaded relationships are simply
available directly on the model.</pre>
</div>
<dl class="attribute">
<dt id="flasker.ext.api.BaseView.methods">
<tt class="descname">methods</tt><em class="property"> = frozenset(['GET'])</em><a class="headerlink" href="#flasker.ext.api.BaseView.methods" title="Permalink to this definition">¶</a></dt>
<dd><p>Allowed methods.</p>
</dd></dl>

<dl class="attribute">
<dt id="flasker.ext.api.BaseView.collection_view">
<tt class="descname">collection_view</tt><em class="property"> = True</em><a class="headerlink" href="#flasker.ext.api.BaseView.collection_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether or not to create the collection endpoint.</p>
</dd></dl>

<dl class="attribute">
<dt id="flasker.ext.api.BaseView.model_view">
<tt class="descname">model_view</tt><em class="property"> = True</em><a class="headerlink" href="#flasker.ext.api.BaseView.model_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether or not to create the model endpoint.</p>
</dd></dl>

<dl class="attribute">
<dt id="flasker.ext.api.BaseView.relationship_views">
<tt class="descname">relationship_views</tt><em class="property"> = []</em><a class="headerlink" href="#flasker.ext.api.BaseView.relationship_views" title="Permalink to this definition">¶</a></dt>
<dd><p>Which relationship endpoints to create.
can be <tt class="docutils literal"><span class="pre">True</span></tt> (all relationships), a list of relationship attributes
names or a dictionary with keys being relationship attributes and values
tuples of (RelationshipCollectionView, RelationshipModelView).</p>
</dd></dl>

<dl class="classmethod">
<dt id="flasker.ext.api.BaseView.attach_view">
<em class="property">classmethod </em><tt class="descname">attach_view</tt><big>(</big><em>*view_args</em>, <em>**view_kwargs</em><big>)</big><a class="headerlink" href="#flasker.ext.api.BaseView.attach_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and attach a view to the blueprint.</p>
<p>New views should be created with this method otherwise the extension will
be unaware of them.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flasker.ext.api.RelationshipView">
<em class="property">class </em><tt class="descclassname">flasker.ext.api.</tt><tt class="descname">RelationshipView</tt><a class="reference internal" href="_modules/flasker/ext/api.html#RelationshipView"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.api.RelationshipView" title="Permalink to this definition">¶</a></dt>
<dd><p>Not an actual view, meant to be subclassed.</p>
</dd></dl>

<dl class="class">
<dt id="flasker.ext.api.IndexView">
<em class="property">class </em><tt class="descclassname">flasker.ext.api.</tt><tt class="descname">IndexView</tt><a class="reference internal" href="_modules/flasker/ext/api.html#IndexView"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.api.IndexView" title="Permalink to this definition">¶</a></dt>
<dd><p>API splash page with a few helpful keys.</p>
</dd></dl>

<dl class="class">
<dt id="flasker.ext.api.Parser">
<em class="property">class </em><tt class="descclassname">flasker.ext.api.</tt><tt class="descname">Parser</tt><big>(</big><em>default_depth=1</em>, <em>default_limit=20</em>, <em>max_limit=0</em>, <em>expand=True</em>, <em>sep=';'</em><big>)</big><a class="reference internal" href="_modules/flasker/ext/api.html#Parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.api.Parser" title="Permalink to this definition">¶</a></dt>
<dd><p>The request parameter parser.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_depth</strong> (<em>int</em>) &#8211; the default depth models are jsonified to. <tt class="docutils literal"><span class="pre">0</span></tt> yields 
an empty dictionary</li>
<li><strong>default_limit</strong> (<em>int</em>) &#8211; the default number of results returned per query</li>
<li><strong>max_limit</strong> (<em>int</em>) &#8211; the maximum number of results returned by a query. <tt class="docutils literal"><span class="pre">0</span></tt> 
means no limit.</li>
<li><strong>expand</strong> (<em>bool</em>) &#8211; if <tt class="docutils literal"><span class="pre">True</span></tt>, same model data will be repeated in the response
if the model is encountered multiple times, otherwise only the key will
be returned. This can be very useful for efficiency when used with a 
client-side library such as Backbone-Relational.</li>
<li><strong>sep</strong> (<em>str</em>) &#8211; the separator used for filters and sort parameters</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flasker.ext.api.Parser.parse">
<tt class="descname">parse</tt><big>(</big><em>collection</em>, <em>model_id=None</em>, <em>model_position=None</em><big>)</big><a class="headerlink" href="#flasker.ext.api.Parser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses and serializes a list of models or a query into a dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>collection</strong> (<em>flasker.ext.orm.Query, list</em>) &#8211; the query or list to be transformed to JSON</li>
<li><strong>model_id</strong> (<em>varies</em>) &#8211; model identifier. If specified, the parser will call
<tt class="docutils literal"><span class="pre">get</span></tt> on the query with this id.</li>
<li><strong>model_position</strong> (<em>int</em>) &#8211; position of the model in the collection</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
<p>This method is convenience for calling <a class="reference internal" href="#flasker.ext.api.Parser.process" title="flasker.ext.api.Parser.process"><tt class="xref py py-meth docutils literal"><span class="pre">process()</span></tt></a> followed by
<a class="reference internal" href="#flasker.ext.api.Parser.serialize" title="flasker.ext.api.Parser.serialize"><tt class="xref py py-meth docutils literal"><span class="pre">flasker.ext.api.Parser.serialize()</span></tt></a>, with the following variant.
When using this method, the <tt class="docutils literal"><span class="pre">wrap</span></tt> parameter is determined by the type
of <tt class="docutils literal"><span class="pre">collection</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">wrap=True</span></tt> if <tt class="docutils literal"><span class="pre">collection</span></tt> is a <a class="reference internal" href="#flasker.ext.orm.Query" title="flasker.ext.orm.Query"><tt class="xref py py-class docutils literal"><span class="pre">flasker.ext.orm.Query</span></tt></a> and
<tt class="docutils literal"><span class="pre">model_id</span></tt> and <tt class="docutils literal"><span class="pre">model_position</span></tt> are <tt class="docutils literal"><span class="pre">None</span></tt></li>
<li><tt class="docutils literal"><span class="pre">wrap=False</span></tt> otherwise</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="flasker.ext.api.Parser.process">
<tt class="descname">process</tt><big>(</big><em>collection</em>, <em>model_id=None</em>, <em>model_position=None</em><big>)</big><a class="headerlink" href="#flasker.ext.api.Parser.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse query and return JSON.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>collection</strong> (<em>flasker.ext.orm.Query, list</em>) &#8211; the query or list to be transformed to JSON</li>
<li><strong>model_id</strong> (<em>varies</em>) &#8211; model identifier. If specified, the parser will call
<tt class="docutils literal"><span class="pre">get</span></tt> on the query with this id.</li>
<li><strong>model_position</strong> (<em>int</em>) &#8211; position of the model in the collection</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
<p>Returns a tuple <tt class="docutils literal"><span class="pre">(collection,</span> <span class="pre">info)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="flasker.ext.api.Parser.serialize">
<tt class="descname">serialize</tt><big>(</big><em>collection</em>, <em>content_key=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flasker.ext.api.Parser.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Serializes a list or query to a dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>collection</strong> &#8211; the collection to be serialized</li>
<li><strong>content_key</strong> &#8211; key to wrap content in</li>
<li><strong>kwargs</strong> &#8211; ignored if <tt class="docutils literal"><span class="pre">content_key</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="authentication">
<h2>Authentication<a class="headerlink" href="#authentication" title="Permalink to this headline">¶</a></h2>
<p><em>under development</em></p>
<span class="target" id="module-flasker.ext.auth"></span><p>Auth Extension.</p>
<dl class="class">
<dt id="flasker.ext.auth.User">
<em class="property">class </em><tt class="descclassname">flasker.ext.auth.</tt><tt class="descname">User</tt><big>(</big><em>email</em><big>)</big><a class="reference internal" href="_modules/flasker/ext/auth.html#User"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.auth.User" title="Permalink to this definition">¶</a></dt>
<dd><p>Base user class.</p>
<dl class="method">
<dt id="flasker.ext.auth.User.get_id">
<tt class="descname">get_id</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/flasker/ext/auth.html#User.get_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#flasker.ext.auth.User.get_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Necessary for Flask login extension.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="skl">
<h2>SKL<a class="headerlink" href="#skl" title="Permalink to this headline">¶</a></h2>
<p><em>under development</em></p>
<span class="target" id="module-flasker.ext.skl"></span><p>Thin wrapper around some sklearn algorithms.</p>
<p>Allows for automatic parameter saving and recovery. Saving fitted algorithms
for later reuse (convenient for parallel computing).</p>
<p>Test results are persisted along with a few metrics.</p>
<p>Currently supported:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">sklearn.linear_model.logistic.LogisticRegression</span></tt></li>
</ul>
<p>Example usage:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">Classifier</span><span class="o">.</span><span class="n">from_engine</span><span class="p">(</span><span class="n">LogisticRegression</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fitted_clf</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">fitted_clf</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="o">.</span><span class="n">precision</span>
<span class="go">0.9576324</span>
</pre></div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="project.html">Overview</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="util.html">Utilities</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, Matthieu Monsch.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>